
我先说说我的思路

## 程序代码是什么？

由语法符，字面量，以及变量构成的文本，其中语法符包括操作符(内置)以及分隔符

分隔符将整个程序的元素构成一个抽象语法树，由嵌套的表达式，或者说列表构成

对于 lisp 而言，

程序的运行就是对这个表达式的递归求值，当求值一个列表时，通过检查列表第一项是什么东东，决定后续的操作(这是 lisp 的特性)

若第一项是操作符，那么运行硬编码的处理方法，否则作为函数运行，依次求值后面每一项，并作为参数列表传入函数

直到整个表达式被求值完毕，得到一个值，程序就运行结束了

## 变量与作用域

### 变量与栈

语法符和字面量很容易理解，而变量是什么？

你可能在不同的编程语言中都有见到过变量，它们如同跨越时空的通道将代码的不同位置连接到一起，形成各种复杂的结构

当你求值一个变量时，获取的不是变量符号本身，而是它背后所`绑定`的对象，而这个对象可能是在很远很远的地方和变量绑定到一起的

那么，程序怎么知道这个变量绑定的是什么东西呢？

那就需要维护变量与值之间的对应关系，最直接的方式就是变量字典

> 字典将变量名字符串与值进行一一对应，如同在字典中建立了目录，输入变量名字符串，便能快速找到对应的值——当然，反过来是不行的

如果有一个不管在程序的什么位置都能访问的这样一个字典，那么就能方便地传递值了，这叫全局变量

有全局变量，自然就有局部变量，当我们想临时操作一个变量名，而不知道外面有没有这个变量，或者不想影响到其它的变量时，就需要局部变量

> 举个例子，在函数中创建的用于传递值的临时变量abcd，自然不希望影响到外面定义的abcd

栈能实现这一点，并且栈通常是和函数的调用在一起的，这叫调用栈

> 栈是一个只能在特定的某端(1个元素)进行增删的列表，这一端叫做栈顶
>
> 添加新的栈顶把原来的栈顶"挤下去"，或者读取并删除原有的栈顶让下面的内容"冒出来"，叫做入栈出栈，或者叫栈的压入和弹出

每当创建新的变量时，将变量字典存储在栈顶，

调用函数时入栈，函数结束时出栈，那么就有了一个临时的存储空间

在函数里创建和操作的变量，都只会在这个临时的空间内，而不会影响到外面，从而实现了局部变量

所以关键问题来了，如果函数想获取**外面**的变量，应该怎么办？

一个很简单直接的想法就是，如果想找一个变量，就从栈顶依次往下找，直到找到一个变量字典里有对应的变量为止

不过有个明显的问题：函数的**外面**，是指哪里？

### 静态与动态作用域

众所周知，函数需要先定义，再调用，而定义和调用通常不会是一个地方

在运行的状态中去找变量，只能找到调用函数地方的变量字典，不同位置调用函数，函数内的变量指的可能就是不同的值，也就是所谓的`动态作用域`

它实现起来简单，很多古早的编程语言都是这样的(据说)

在定义的状态中去找变量，则需要函数额外保存定义时的调用栈中的变量字典，此时不管在哪里调用函数，函数中的变量指的值都是不变的，叫`静态作用域`

现代的编程语言基本都是静态作用域的(确信)，并且函数的闭包就依赖于此

静态作用域和动态作用域各有优缺点

- 静态作用域可以让函数更加稳定，定义时外面有哪些变量也更直观，并且由此产生的闭包可以存储状态，改进一点点就能变成面向对象，感觉也更方便在编译时检测错误
- 动态作用域可以字面意义上拼接代码，不用去管烦人的输入输出，获取整个调用栈的情况能实现一些“黑魔法”，事实上 python 的 frame 对象就补充了动态作用域的功能

所以为什么不**两个都要**呢？

那么问题就来到了函数的定义上面

## 函数定义

> 程序需要有过程的抽象和具象，，也就是函数的定义和调用
>
> ——我自己说的

如果一开始就设为静态作用域的话，动态作用域肯定就没戏了

所以设定基础为动态作用域

静态作用域的基础是保存状态，而这一点在对象的生成上面有体现，所以，可以将函数定义视为函数对象的生成，而需要的静态变量就在生成函数时塞进去就行了

当函数定义时，外层肯定是在运行的，但是函数内部不是，由于这东西是递归调用的，为了将运行与不运行的代码区分开，于是需要类似quote的东西，或者干脆由操作符处理，即使用操作符处理，行为也是类似quote的

<Cover>也就是函数的定义其实和在代码文本(字符串)里面定义字符串一样</Cover>

quote一个列表，与包裹字符串类似，但是不一致

相似在于，它们都是可以包含自身的语法的

不同在于，字符串是列表的结构，而quote后，可以展开变成树结构

既然和字符串类似，那么当然也可以采用格式化字符串的方式，让它在即使是整体不求值的情况下，也**选择性**地求值一部分。。。(这意味着需要加入转义，是实现上的细节)

这就是定义函数时，插入静态作用域变量的依据

## 其它

整个程序是一个表达式，同时也是一个函数，可以有参数

虽然写代码时，默认最外层代码是运行状态的，但是本质上，它还是处于定义状态，只不过一般而言不需要区分，这一点也是需要注意的

IL 基于动态作用域，但是函数定义时可以同时获取动态，静态作用域的值并且设置参数——即便根本没有形参列表

所有的对象都可以放到表达式开头(希望可以)

函数是特殊的列表，说是特殊，也就是把`lambda`放到了列表的开头而已，可以像是一般的列表一样处理

## hello world

```
print "hello world"
```