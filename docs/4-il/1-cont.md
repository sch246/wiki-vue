# 调用树

关于协程和 continuation, 有很多共同点

## cont

对于 CPS(Continuation Passing Style) 形式的函数调用

在代码段 A 里调用函数 f

调用的瞬间，暂停 A 的执行，并且记录执行到的位置，即产生一个 cont(continuation) 对象

跳转到 f 的代码块执行，并且传入 cont

这样当 f 运行完时，就可以调用 cont 返回到 A 继续执行

同时这也意味着函数可以不调用这个 cont 而是其它的 cont, 继而转到其他的代码块而不是返回原来的代码块执行——如同协程一般

调用 f 这个跳转本身，是不是也可以看作是 cont 的调用呢？

cont 会产生调用树，因为可以在不暂停的情况下生成 cont, 就像是保存快照一样

调用 cont 会丢弃当前的变量字典，且一般从生成 cont 的后面继续执行，这意味着cont是一次性的

它标记的是执行中的某个时刻，使得可以在任意时刻携带数据返回这个时刻，而不是代码块本身，这是它烧脑的地方

在调用树中为了返回对应的节点，必须留存有对应的 cont, 这意味着可能存在无法返回的节点，其应当被垃圾回收机制清除

## 协程

不管怎样，这和协程的工作具有共同点

不同的是，协程的流程控制需要一个调度器——且线程中一般都是唯一的

调度器应当有个待执行列表

以及，在代码执行过程中，可以主动暂停自身的执行，让调度器执行其他需要执行的代码块

并给出继续执行的条件，以供调度器再次调用

那么用这种方式调用函数，在代码块 A 中调用 f, 就可以是

把函数放进待执行列表，并且把自身的继续执行条件设为函数运行结束

然后暂停自身

那么一切应该按预期运行，当然许多细节需要补充，不过我觉得应该可以达成某种美妙的统一

或者，也可以是设置一个我认为的 Future 对象——那样的话和 cont 就更像了——继续执行的条件是 Future 被设值，而这需要把 Future 对象传递出去

只不过和 cont 的不同之处在于，cont 是调用即终止，而这里设值只是把它放入待执行列表，暂停或终止当前代码块的执行需要后续手动操作

并且我寻思这东西的理解难度应该也比 cont 低一些

这种状态似乎同样可以垃圾回收——当继续执行的条件不可能达成时进行回收

