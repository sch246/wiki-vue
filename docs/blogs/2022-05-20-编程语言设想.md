---
title: 编程语言设想
tags: [编程语言, lisp]
date: 2022-05-20T12:00
---

import Cover from '@site/src/components/cover/main';

看了黑客与画家

里面，提到了现在就可以设计百年后的编程语言了

那么，让我构想一下吧

:::caution 以下为开脑洞胡思乱想的结果，不保证逻辑通畅依据合理

:::

<!--truncate-->

## Lisp 逆序

虽然里面说应该尽可能摆脱对编程语言现有认知的影响，不过我觉得参考也是很重要的啊

比如 Lisp 语言，被称为上帝的编程语言的东东

就 Common Lisp, Scheme, Racket 和 Arc 等我现在看到的来说

- 里面的列表由点对嵌套构成，且嵌套的是后一个点对

- 计算一个列表时总是从头开始判断，而计算值时，列表头是最后解析的

这样整个代码就是一颗树的形式，且根部在开头

运行时从根部出发，而计算解析则从末端开始

打代码可以看做是一个向计算机叙述自己的思路的过程

一直从前往后打完整个代码的话，就像是先决定了整体框架，随后慢慢完善细枝末节一样

**我觉得这和自然语言的输入是不一样的**

这种解析模式更像是我先决定了做什么，然后去完善具体怎么做

而信息的输入，更像是我先有了这些信息，一步步总结修改，最后再得出结论

一个是演绎推理的输出的过程，一个是学习抽象的输入的过程

众所周知，最好的解决办法就是阴阳合道，我全都要

Lisp 的宏系统和各种特殊控制符就是让打破这种解析顺序成为可能的

那么，**如果直接反过来会怎么样**，如果嵌套的是前一个点对，函数头放在最后解析呢

那么每次往后添加元素，都有可能对整个树的结构进行重构，就像说话没说完可能意思相反一样

不过相对的，完善细节，补充修改前面已有的信息就会变得麻烦一些

这也是我在b站看到的那个函数式编程的视频里 λ演算 原本的解析顺序，从前往后计算解析

虽然那个视频里函数头依旧是在开头，不过运算过程本质上是把函数作为基本的输入，一步步形成新的函数，把复合到一起的函数与最后一个元素结合得出结果，而结果依旧是个函数，可以继续往后面加，其解析是从前往后的

我觉得数学定理的输入和自然语言的输入也是类似的

显示在明面上的是碎片的列表

但是隐藏的逻辑则不断由细节生成结论

结论与状态结合形成目的

其输出则是由目的出发逐渐完善细节

最后输出的细节被读取，形成闭环

这是一个先学习再应用的过程

或者说是先输入再输出的过程

编程就是人向机器输出

那么要编程语言符合人类的操作习惯，就需要构建一个虚拟的对象，走完人类的信息处理流程

总之就是像说话一样编程，然后把处理交给计算机

![](https://img1.imgtp.com/2022/05/20/3WWiVySs.png)

明面上的碎片列表

暗面里的逻辑生成

由于只是逆序一下，本质上和 Lisp 应该还是等价的 (?)

## 自编程与命令式

我这里先定义一下

自编程指程序处理自身代码片段的能力

命令式指可以由命令行进行一条条输入并产生一条条输出(一条消息内可以包含换行)，每次的输入都相当于在代码上进行累加

那么编程语言就似乎变成了两部分

执行任务的代码，以及操作代码的代码

这里的命令式就非常符合前面提到的从前往后解析

并且也适合作为操作代码的代码

事实上，有了自编程的性质，数据就与过程等价

那么操作数据的代码，也可以是操作代码的代码

流程控制在某种意义上也是操作代码的代码

问题来了

- 一般的操作可以被操作代码的代码定义，那操作代码的代码怎么定义
- 如果每一行都是后续添加上去的，这样一行行的怎么保证可读性
