# IL

![](https://s2.loli.net/2022/10/23/qvgBXAlaGi4rPw7.jpg)

啊哈哈，在积攒了一段时间的想法后，我又来设计语言了

意识到了过于动态的话我现在没办法驾驭，所以还是常规一点好了

先命名为 IL 吧，indent lang 的缩写，当然理解成 indent list 也没问题

顾名思义，它的写法和 python 类似，但是本质上是 lisp

运行代码需要先将代码转成lisp的格式

## 基本语法

```
# `#`开头为注释
a # 这是行内注释
```

### 表达式
```
# 没有语句，所有的都是表达式
# 表达式可以是单个元素，或者被括号括起来的多个元素
# 整个代码就是个表达式，构成树形结构，求值即运行

# 括号内可以用` `，`,`和`;`进行分割，这3个不算元素，以下等价
(a (b (c d)))
(a, b (c d))
(a; b, c d)
# ` `，`,`和`;`会将空内容省略
# 上面也可以写成
( a;; ,; b  , ,, c   d; )

# 以下等价
a,;
a
a,
a;

# `,`和`;`无法表达多层括号的对象
f;, a b
# 不等价于
f ((a b))
# 而是
f (a b)
```

### 缩进
```
# 括号内只有一个元素时，求值返回其本身，当在`缩进`下时，括号可以省略
# `缩进`是语法糖，意味着在编译期完成
# `缩进`的层级意味着被括号嵌套的深度, 直接写(每行开头不空格)是第0级缩进
# 第0级缩进外面其实已经有2层括号了(整个代码一层，每行自动套一层)
a
a b c
# 等价于对下面的进行求值
(a)
(a b c)

# 每增加4个空格，缩进增加一级
# 为了标明表达式从代码树的哪里开始"分叉"，表达式的`第一行`需要例外
# `第一行`的每个元素与下一级的每行平级
a (b) (c d)
# 等价于
a (b)
    c d
# 或者
a
    b
    c d

# 缩进在`;`，`,`之后处理，以下等价
a; b
    c

(a b)
    c

(a b) (c)

# 当括号内第一个元素需要嵌套时，问题会变得麻烦
# 此时`|`用于占位，必须放到开头，它不算元素
# 如果依旧想保持a的括号深度(多此一举)，可以用解包:`.`
# 因此上面也可以写成
|
    . a
    b
    c d
# 写在一行是这样的
| (. a) (b) (c d)
# 它被解析成
a (b) (c d)

# 括号可以跨过缩进
(a b
    c d) (e f
    g h)
# 等价于
(a b (c d)) (e f (g h))
```

### 括号处理
```
# `.`和`..`用于解包，必须在括号开头，是语法糖，不算元素
# 在缩进之后处理，也就是此时只剩下括号
# 以下等价
a b c
a (.. (b c))
a b (.. (c))
a (. b c)
a b (. c)
# 以下是特殊情况
a b c (.)
a b c (.. ())
# 嵌套解包
a (. (. b c))
a (.. ((.. (b c))))
# 以下会语法错误
# a b c (..)
# a b (.. c)

# `:`会将后面所有元素括起来，是语法糖，不算元素
# 若后面没有元素，返回一个空括号
# 在缩进之后处理
# 要解读它可以先将它当作普通元素来看待
a b ((c d) (e f))
# 用`,`，`;`表示是这样
a; b; c d, e f
# 等价于
a b: (c d) (e f)
# 或者
a b: c d; e f
# 或者
a b:
    c d
    e f
# `:`可以没有歧义地嵌套，它后面必定是括号内最后一个元素
a b: c d: e f, g h
# 等价于
a b (c d ((e f) (g h)))
# 可以写成
a b: c d:
    e f
    g h
# 或者
a b:
    c d:
        e f
        g h
```

## 基本类型

### 数字
```
#
```

### 字符串
```
# 使用双引号创建字符串
"a string"
# 使用3*双引号创建多行字符串
"""
a long string
"""
# 字符串允许一般的转义
"awa\nbwb"
# 在字符串中使用反引号插入表达式
"`"str"`" # -> "str"
# 因此输入反引号需要转义
"\`"
# 直接使用反引号将创建原始字符串，其中不能包含反引号
`\`
# 但是可以换行
`awa
www`
```

### 列表
```
# 使用`list`创建列表
list: 1 2 3
# 它会对每一项依次求值，并返回结果构成的列表

# 创建
a = [1 2 [[3 4] 5 6]]
# 取值
a 0     #-> 1
a (0)    #-> 1
# 取多个值
a (0 1)  #-> '(1 2)
# 嵌套取值
a 2 0 1   #-> 4
# 嵌套+取多个值
a 2 (1 2) #-> '(5 6)
# 取多个值+嵌套
a (0 1 (2 0 (0 1)) (2 1) (2 2)) #-> '(1 2 3 4 5 6)
# 修改值
= a 0: 0
# 删除值
pop a 0
del a 0
# 增加值
push a 0 0
push a 1 0
```

### 字典
```
# 使用`{}`创建字典
{a=1, b=2, c=3}
# 等价于
{'a 1, 'b 2, 'c 3}
# 也可以写成(花里胡哨)
{'a:1, 'b:2, 'c:3}
# 等价于
dict: a=1, b=2, c=3
# 等价于
run: a=1, b=2, c=3, \
    stack.vars
# 它会创建变量字典，对每一项依次求值
# 运行期间创建的变量会存入变量字典，并被它返回，不会直接影响外面的变量字典
```


## 变量

### 声明
```
# 直接写就是声明
a
```

### 赋值
```
# 用`=`进行赋值
= a 1
# quote对象在开头时，触发赋值
'a 1
# 语法糖
a = 1
# 通过变量字典赋值
vars['a] = 1

# 赋值表达式返回被赋的值
print: (a=1)  # -> 1

# 批量赋值，数量不匹配时报错
= a b c: 1 2 3
# 等价于
= a b c (1 2 3)
# 等价于
= (a b c): [1 2 3]
# 注意，不等价于
= (a b c) (1 2 3)
# 不等价于
= a b c [1 2 3]
# 当`=`不在首位时，它只读取左右各一位
(a b c) = (1 2 3)

# 打包解包参考python，规则一致
= a *b c: 1 2 3 4 5
= a *b c: 1 2 *[3 4 5]
= (a, (*b, c)): [1 [2 3 4 5]]

# 赋值可以嵌套，相当于设置默认值(花里胡哨)
# 这意味着即使参数少匹配了也能用默认值补上
# 如果最后没补上，报错
= ((a, (*b, c=0))): 6, [7 8 9 0]
```

## 函数/过程

### 创建
```
# 过程, 动态作用域，不创建栈
# 这意味着参数列表中的变量会被实际创建
= f: proc a (b (*c)):
    do, A
    do B
f (1 (2 3))
# 等价于
= f: proc:
    = a (b (*c)): 1 (2 3)
    do, A
    do B
f()
# 等价于
= a (b (*c)): 1 (2 3)
do, A
do B
# 缩进自然可以合起来
= f: proc a (b (*c)): do, A; do B
# 原地执行过程，并没有实际作用(大概)
(proc:
    ...
    ...)()
# 如果再传个过程进去(花里胡哨)
(proc f:
    f()
    ...)(proc:
    ...)

# 匿名函数，静态作用域，创建栈
# 参数同样意味着赋值
= f: func a (b *c):
    ...
# 采取的是可以有关键字的赋值？

# 函数，静态作用域，创建栈，有默认值
def f (a, b=123, c=456):
    ...
# 调用
f (1)
f (1, 2)
f (1, c=8)
# 采用的是可以有默认值和关键字的赋值）？

# 动态作用域，创建栈
# 依次运行并返回最后一项
run:
    ...
```
