# 类型和类型系统


## 只是个笔记

- [柯里化的前生今世（十）：类型和类型系统](https://zhuanlan.zhihu.com/p/34200056)

看不懂了

## 形式化方法

![](https://s2.loli.net/2022/07/29/OIkJtTsWBoLvx9R.png)

## 历史

> 因此，类型理论，逻辑学和范畴论产生了关联，
>
> 这种三者的对应关系，称为Curry-Howard-Lambek correspondance。

————[知乎 - 语言背后的代数学（十）：Curry-Howard-Lambek correspondance](https://zhuanlan.zhihu.com/p/35322455)

## 类型系统

> 类型系统使用了证明论（Proof theory）方法，通过给程序中的值指定不同的种类，来证明程序的某些行为不会发生。

类型和它所对应的值的区别在于，类型是值的某种共同点，它比一个完整的值所含有的信息更少

那么用类型能推出的结论，值也能推出

## 一堆概念

- `运行时错误`
    - 类型
        - `未捕获的错误`
        - `被捕获的错误`
- `安全性`
    - 定义
        - 若一个程序不会产生`未捕获的错误`，则称它是`安全的`
        - 如果语言中的所有程序都是`安全的`，就称该语言是`安全的`。
    - 实现
        - `运行时检测`
        - `类型校验`
- `类型化`
    - 定义
        - 变量可以被赋予非平凡的（即非单一通用类型）类型的语言被称为`类型化语言`
- `类型标记`
    - 定义
        - 如果程序语言的语法中含有类型标记，就称该语言是`显式类型化的`（explicitly typed），否则就称为`隐式类型化的`（implicitly typed）。
- `行为良好`
    - 前提
        - 不运行代码的, 无法判断代码是否有运行时错误
    - 定义
        - `被禁止的错误`
            - 定义
                - 一部分的`运行时错误`，包含全部的`未捕获的错误`，以及一部分被`被捕获的错误`
        - 如果程序不会产生被`禁止的错误`，就说该程序`行为良好`（well behaved）
    - 图示
        - ![](https://pic3.zhimg.com/80/v2-d809e989a93828caf4c12c10220e459a_720w.jpg)
- `静态检测`和`动态检测`
    - 判断
        - 若语言能在运行前通过`静态检测`保证行为良好，称为`被静态检测`的语言。
        - 若语言能在运行时通过`动态检测`保证行为良好，称为`被动态检测`的语言
- `强类型`和`弱类型`
    - 定义
        - 一个`类型化语言`，如果所有合法的程序都是`行为良好`的，就称该语言是被`强类型检测的`（strongly checked）。
        - 如果某些`未捕获的错误`不能被`静态检测`，就有可能出现`不安全的`代码，我们就称该语言是被`弱类型检测`的（weakly checked）。

> 因此，强类型检测的语言具有以下特征：
> - 不会发生`未捕获的错误`——安全性。
> - 那些指定为`被禁止的错误`的`被捕获的错误`不会发生。
> - 一些`被捕获的错误`可能发生，需要程序员来避免。

定义这么多概念，，，太长不看

我在b站看到了这样的例子

- 动态类型与静态类型的区别
    - 你能不能给一个变量换个类型
- 强类型与弱类型的区别
    - 你能不能将不同的类型当成一种类型用
        - `1 + 1.0` 能不能运行
        - `1 + '1'` 呢


## Pure and Lazy

### 非严格语义（non-strict semantics）

> 在Haskell规范中，并没有要求使用惰性求值策略（evaluation strategy），
只是规定它是一种非严格的语言（non-strict language），
具体的求值策略取决于实现。

> 对Haskell来说，GHC是最流行的编译器，
> 它使用了惰性求值（lazy evaluation）。
>
> 在没有歧义的情况下，人们常用lazy暗指non-strict，
lazy更直观更有利于沟通。

- '引用透明性'（referential transparency）
    - 定义
        - 程序中的表达式总是可以用它的值来代替。
- `纯函数`（pure function）
    - 定义
        - 这个函数对相同参数总是输出相同结果
        - 这个函数没有副作用（side effect）

- 结论
    - `纯函数`具有`引用透明性`。
    - 一旦语言拥抱了`惰性求值`，就不得不保证`引用透明性`
    - `纯函数`是不是解决问题的最佳方式，目前尚无定论

## 历史上的纯函数式惰性语言


> 在80年代中期，很多研究者都想设计实现一个纯函数式的（pure）惰性语言，Miranda和Lazy ML是其中的两个例子。

> 我们想要一门用于研究语言特性的语言，因此我们决定任何人都可以扩展和修改语言本身，重新实现或者发行。

> 于是，Haskell的故事就这样开始了。