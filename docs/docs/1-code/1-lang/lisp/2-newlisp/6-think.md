# 设想


由于python在修改函数上面还是不够动态于是我尝试找lisp了

## quote和eval

对于newLISP中的变量名(，或者说，对一般编程语言中的变量名)

一般而言会进行求值, 在上下文中根据变量名得到一个值

- lisp 中
    - 函数会对符号进行求值并传入
    - 宏不会
    - 内建函数有特殊的行为，可能求值，也可能不会

**这是变量的一般用法。**

然而，也可以使用`(quote xx)`来避免被直接求值

可能是因为lisp中过程即数据，当过程作为数据传递时，需要与其它过程作区分

> `'a` 等价于 `(quote a)` , 这是lisp的一个语法糖

不过，可以从另一个角度看待`quote`

`eval`函数作用于变量本身时，会对变量进行求值，就像解析器碰到一般的变量名那样

当`eval`碰上`quote`时，对其求值，就结果而言会消掉一层`quote`

`(eval 'a)`等价于`a`, `(eval '(+ 1 1))`等价于`(+ 1 1)`

> 我认为这里事实上并不是eval消掉了quote
>
> 而是解析器对`'a`求值得到`a`，`eval`再求值得到`a`的值

> `eval` 和 `quote` 的关系让我想到了C语言里 `*` 和 `&` 的关系
>
> 我很好奇为什么eval没有语法糖的样子

于是`eval`与`quote`互为相反的操作，并且可以一直套下去

解析器的求值也可以看做一层eval

对于宏而言，这里没有使用求值，对于其它情况而言，一般都会加一层eval

问题来了，eval是不可逆的，会损失信息，默认的eval解析导致了(变量名/过程)不能直接作为数据

得加上`quote`这么个不上不下的东东来抵消它

显然`quote`不是函数，为了逻辑自洽，宏的出现似乎变得有必要了(bushi)