
::: warning 已废弃
勉强留个案发现场？
:::



据《黑客与画家》所说，现在就可以设计百年后的编程语言了

正好我一直有关于对世界的思考，加上最近对QQbot的搭建，让我有了更多的想法

我想搭建一个在尽可能方便编辑的前提下的，自由度尽可能大，尽可能动态的语言

让简单是事情不复杂，复杂的事情变直观，极端复杂的事情变得有迹可循

我想综合python，newlisp，html，以及我的关于节点的想法，抛弃现有编程语言的束缚，看看能产生个什么思路

## 现象

在思考之前，应该先收集信息，人们对于麻烦的事情应当已经发展出各种解决方案的雏形了才对

当人们想做一个具有相对复杂交互的图形界面时，会想到用网页来制作

比如昨晚C60就有这个需求，然后结论是用网页加js会比较简单

或者，jk也推荐了游戏引擎godot，据说交互很厉害

### 查找

对于查找东西，启动应用，或者一些快捷功能，我习惯使用utools进行各种活动

这是关键字查询，并且每打一个字符都会有即时反馈

菜单与文件夹结构是层级结构查找的范例

而tags和分类也是视频和博客网站的必要东东

linux的文件搜寻与过滤是一绝，其中管道符起了大用

vscode可以限定范围，然后使用正则表达式进行匹配过滤

程序的执行，就是在合适的条件下干合适的事情，找到合适的事情的过程，是否可以看作一种特殊的查表呢

或者说，查表这件事情，是否就能看作一个程序执行的过程？

## 信息

我们可以使用信息来描述世界的运转

当一个信息出现了，如果我们监测这个信息带来的一切改变，其影响的边缘将以光速扩散开来

一切的影响都被绝对局限在一个范围内，所谓光锥之内即为命运

我们可以把范围追踪得更精确一些

如果我们想要一个程序的结果，追踪它的所有输出，

就会发现所有输出的信息，归根结底来自于输入的改变

而输入连接着外界的另一个输出，输出连接着外界的另一个输入

它的输入输出与整个外部世界的输入输出相互匹配

构成信息流闭环

包括我们自己在内的所有逻辑应答都是如此

甚至粒子的运动，自然的规律亦能看做简单的逻辑应答

(不要扯量子力学，我这里关注因果律)

(而且目前没关注时间的流逝,我也不知道怎么关注)

既然每个输出和输入都是对应的，我觉得只关注输入就行了

比起一件事情会导致什么后果(由因索果)，

我认为关注是什么导致了它(由果索因)可能更好编程一些

你不清楚向水里投一块石头会导致怎样的连锁反应

但是只要设定好了每滴水行动的原理，那么整个连锁反应就变得可模拟了

## 节点

虽说如此，高频检测全部的条件是否成立是让人无法忍受的

当石头落入水面时，只需要检测并改变石头遇到的水就行了

水会触发其它的水的改变

于是乎，在输入旁边放一串初始的触发器，然后在其中再放其它的触发器，，

以此类推，直到遍布所有可能影响到的位置

这可以看作if语句的嵌套，也可以看作函数的调用，没有区别

我将其称为节点

对程序的调用入口，可以看作一个输入，源代码，其它文件，网络也可以看作输入

输入可以由输入派生，倒不如说每次新的节点触发都可以看作一个新的输入

目前为止，并不需要锁死在单线程上，倒不如说多线程更好

根据节点在程序中的位置，可以分为输入节点，中间节点，输出节点

输入节点不需要设置触发条件，输出节点不需要设置执行动作

理论上是不需要执行动作的，仅凭节点是否激活的布尔值应当就能传递信息

但是调用外面的api需要函数啊，需要传递数据啊

输入进来也总有各种数据吧，数据怎么存储处理啊

总不能用节点是否激活的布尔值吧

咳咳，扯远了

总之编程大概就是设计节点，以及节点之间互作用的一个事情

节点之间的相互作用，需要不同节点能共存，并且能够相互访问

我寻思可以用多线程，异步，类或命名空间，或者把数据存储在调用栈的根部实现

## 目标

- 可以使用“因为..所以..”的方式编程，当满足条件时则会触发
- 它可以检测代码自身的解析和执行状态并触发

::: details 草稿2

## 元代码

操作数据的过程称为代码

lisp中，通过quote，eval以及宏，代码也可以是数据，于是可以出现操作代码的代码，我称其为元代码

语言的语法和语法糖的设置也应该是元代码，这个角度可以解释为什么有人认为lisp可以说是没有语法的语言

虽然但是，更深层次的语法和语法糖并不能在lisp中自定义

<Cover>比如你不能把所有的函数头都放到列表末尾，或者为函数调用添加关键字参数，或者去掉括号，把它变成python那样缩进分段的语言</Cover>

语法和语法糖涉及解析器如何解析代码字符串，我觉得这个应该可以通过类似css的方式自定义

然后应该允许使用类似style的方式在一个区域内干涉代码的解析过程

我理想中的元代码应当能动态地完全控制代码，我们能进行的编辑它应当也都能实现

并且应当有足够灵活简单的方式控制一段代码是作为代码解析还是作为数据传递

我觉得应该给eval也加个语法糖，比如`.`

eval和quote能作用于字符串，或者递归地作用于列表

对于一个列表的解析，需要先解析其中的每一个元素，然后再执行列表本身，quote阻止了全部，eval执行了全部

解析每一个元素但不执行列表，可以通过list函数创建列表来实现，我觉得这也应该变成语法糖，比如`` ` ``

应该有一个函数返回参数自身，就设为nil好了

`(nil)`返回nil，`(nil a)`返回`a`

## 变量与函数

数据处理离不开变量，它起到一个传值/占位的作用

过程可以被执行仅当其中变量的值都被确定(实例化)

如果过程可以反复实例化并执行，就可以认为定义了一个函数

看起来就是函数的一部分变量被不断赋值，使用，然后消失

除了标记结构的符号外，代码可以仅由字面值以及变量名(也许应该叫标识符)构成

- 结构标记符号
- 字面量
    - 数字
        - 整数
        - 浮点数
        - 复数
    - 字符串
    - ...语法糖
- 变量名(标识符)
    - 真变量名
        - 常规数据类型
        - 函数
        - ...自定义类
    - 内置函数
        - 关键字运算符等常规内置函数
        - 数据类型
        - ...语法
    - ...语法糖
- ...语法糖

变量必须赋值才能取值，一个数据可能有多个变量与之对应

其映射的数据可能是动态变化的，可以视为存储了一个指针(数据在内存的地址)

变量具有作用域，一般不会超过一个节点及其子节点的范围

> 在if嵌套中能访问外层的变量，在函数调用中一般不会，newlisp除外，它能在函数中访问调用函数的节点中的变量，并且函数中创建的变量也能在外层访问到，唯一不能在外层直接访问的就是定义函数时的临时变量，除了定义函数的临时变量外，任何变量都是全局变量
>
> 相对的，newlisp引入了命名空间的概念以存储状态和避免命名冲突
>
> 也许可以在节点内创建全局变量，不过这时候变量应该是以根节点为参考了

变量传递分为引用传递和值传递，值传递指将数据复制一份

在有`quote`的情况下，引用传递还分为传递变量所存储的指针(数据地址)，或者传递变量名本身

> 复数变量名-\>唯一数据地址-\>唯一数据

### 节点与函数

我觉得newlisp的设计很好，所以我也打算这么做，所有创建的变量都是全局变量，只有函数调用时设定的变量是放进栈的临时变量

触发节点分为2步，设置输入参数，以及(判定条件然后)触发

函数则是接收一个格式，抽出其中的量，并且转化为另一个格式

整个执行需要的参数大概是这样`(func input)`，其中函数需要的数据是`(style output)`

如果要能分段输入参数的话，input可以是`(merge *inputs)`

如果需要更便捷的触发的话，可以设定满足style后直接触发output，不过最好设置一个范围

从input到style可以与set的功能重合，但是这个set创建的变量应当是临时变量

这意味着set应当支持格式匹配，就像这样

- `` (set '(nil a (b *c) *d) `(nil 1 '((2 3) 4 5) *'(6 7) 8)) ``等价于`(set 'a 1 'b '(2 3) 'c (4 5) 'd (6 7 8))`

set成功后相当于设定好了参数，触发节点时就是参数俱备的状态了

节点要设置成能像石头投进水一般连锁触发，节点的链接应该能向前链接，由于内置函数和参数的存在应该也要能向后链接

节点的本质是条件触发，函数的本质是代码拼接格式转换创建变量

### 设定

我设定如下：

::: warning 这些都是我编的，不要随便往已存在的语言上套

:::

节点使用大括号创建，是列表的一种，求值节点时将会从头到尾求值一遍并返回最后一项的值

整个文本文档就当是根节点内的内容

变量以dict形式作为节点的属性

代码中对某变量取值时，如果本节点没找到，递归查找调用栈的变量(函数能访问调用它的节点的变量)，直到全局变量和内置变量

(也可以参考python的frame每次生成新的变量字典？)

取值时默认使用复制传递，使用`'`(`quote`)作前缀表示变量名，等价于有一定格式检查的字符串

赋值时，则对本节点内的变量进行赋值，字符串(`'a`或`"a"`)作为列表头时起到赋值变量的作用，是`(set 'a xx)`的语法糖

> 可一次赋值多次，例如`('a 1 'b 2 'c 3)`
>
> `(set 'a xx)`可以继续展开为`(&__dict__ 'a xx)`

使用`&`(`ref`)以表示对应数据的引用，例如使用('a &a)以对全局变量进行引用传递而不是值传递，引用会尽量保持，需要值的时候输出对应数据

读取未定义变量时返回nil，值为nil等于删除该变量

变量命名参考python，常量采用FOO_BAR，类采用FooBar，其它都采用foo_bar

可以在解析时添加参数以达到函数的效果，被解析的对象中使用`__args__`来获取输入的参数列表

- `(eval obj *__args__)`

单个`_`是占位符，是内置常量

函数调用时会将输入的变量与下划线开头的变量依次进行赋值，少了则设为nil，多了也不管，使用nil进行占位

如果想要覆盖列表中的变量a，在参数末尾添加`('a 1)`，它会返回`nil`

副作用是赋值本节点的变量a，若想规避该作用，可以创建节点并在其中调用函数`{(f 1 2 ('a 1))}`，这会阻止函数中的变量被外面访问

这是一般的lambda函数
- `(fn (a b) (++ a b) a)`

实际上传进去的参数
- `(fn '(a b) '(++ a b) 'a)`

我打算设计为
- `(fn '((a b) (++ a b) a))`

添加语法糖
- 使用`` (def 'f '(a b) '{(++ a b) [+ a]}) ``来进行更明显的函数定义
    - 它等价于`` (set 'f (fn '(a b) '{(++ a b) [+ a]})) ``
    - 等价于`` (set 'f '{(++ _a _b) [+ _a]}) ``，函数外将不能访问里面的变量

使用`__here__`以获取当前调用栈对应节点对象(当前函数的实例)，节点作为字典就是能在节点调用到的变量组成的字典，若未命名则赋予以数字

使用`__dict__`以获取节点内新创建的变量组成的字典

`__root__`以获取根节点，根节点下的变量为全局变量

`(__src__ 1)`就是上一个节点，`(__src__ -1)`就是根节点，`(__src__ 0)`就是本节点，可以把`__src__`看作调用栈的节点列表

> 假设d是个字典对象，使用`(&d 'a)`返回键a的引用，使用`(&d 'a 1)`或(set (&d 'a) 1)设键a值为1，使用`(&d 'a nil)`或`(del (&d 'a))`删除键a
> 
> 当d实现了字典但无法直接查询时，使用`(key &d ..)`也可实现同样的效果，上面那是个语法糖
>
> 使用`(dict ('a 1) ('b 2))`创建字典，等价于`{('a 1) ('b 2) __dict__}`
> 
> 假设ls是个列表对象，查找方法与字典相同，但是`'a`需要换成整数，`key`需要换成`index`，允许负值，使用 `(&ls a b)` 返回索引a到b的引用组成的列表，`(ls a b)`等价于 python 的 `ls[a:b]`
>
> 使用`(list 1 2 'a b)`创建列表，等价于`` `(1 2 'a b) ``
> 
> 字典对象允许使用列表的方式进行查找，(index d n)会按照键值排序将字典的值转化为列表并查找第n个
>
> `(is list lst)`等价于`(list? lst)`，会返回lst是否是个list
>
> `(to list lst)`等价于`(list! lst)`会返回强制转换为list的lst
>
> `(in lst a)`会返回a是否在lst中

增加语法糖

- 柯里化：`([++ _ x] &y a)`
    - 等价于`((curry ++ _ x) &y a)`
    - 等价于`(++ &y x a)`
- 复合函数：`(g 3 ((f 2) (h i)))`
    - 等价于 `([g 3]:(f 2):h i)`
- 连续调用：`([(a 1) 2 3] 4)`
    - 等价于 `a(1)[2 3](4)`
    - 这将允许以a(b)的形式访问字典，以a(1)的形式访问列表，以f()的形式运行函数

那么尝试写出《黑客与画家》中的那个输入n返回给n增加i的函数的函数

假设变量a为0，目标是随后每次调用函数f并传入参数i都会给a加i

``` Arc可以这么写 http://arclanguage.org/
(def foo (n) [++ n _])
(= f (foo a))
(f i)
```

``` 我觉得我的可以这么写
('foo `[++ _])
('f (foo &a))
(f i)
```
:::

::: details 初始草稿？

## 结构

既然编辑的是节点与其之间的互作用，就需要定位和区分节点的手段

不止代码中静态的区分，还有运行期间动态的区分

命名的节点会一定程度增强可读性，节点多了肯定需要大量匿名节点


它的核心应当是十分简单的，而语法与内置函数都应该能由核心实现，并提供一定程度的自定义

它应当是脚本语言，不区分编译运行，具有运行时自修改的能力

它应当能编辑模块，并且能支持复杂系统

它应当支持并行和异步，而不只是单线程

函数应该既支持开放，也支持闭包

应当默认使用复制传值，使用quote以传递引用

函数应当允许分段传入参数，随时调用

应该能在任意一段代码访问到整个调用栈

应该能完全控制解析器是否解析代码对应的字符串，解析多少层

变量应该作为字典存储在代码段中，哈希表可以用变量实现

附带的，应当支持lisp格式和缩进格式混用

equa，set，for应该统一，字符串应该被视为一种列表

set应当支持格式匹配，函数调用过程可以看做set与代码段的复合，因此函数定义可以把set抛弃掉)

应当支持类似python的打包与解包，以展开列表到上一层括号中

列表索引应当支持切片，以及允许负数

:::